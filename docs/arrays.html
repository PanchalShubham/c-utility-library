<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Meta data -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Set Title -->
    <title>Utility Library | arrays.h</title>

    <!-- Favicon -->
    <link rel="shortcut icon" type="image/x-icon" href="icon.png" />

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
          integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <!-- highlight js-->
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- Styles -->
    <style>
        @import url('https://fonts.googleapis.com/css?family=Libre+Baskerville&display=swap');
        *{
            font-family: 'Libre Baskerville', serif;
        }
        body{
            background: white;
            color: black;
        }
        table {
            width: 100%;
            text-align: justify;
            border-collapse: collapse;
        }

        table, th, td {
            padding: 5px;
            font-size: 18px;
            border: 2px solid black;
        }
        table{
            margin-top: 10px;
        }

    </style>
</head>
<body>
<div class="container">
    <h3 style="padding-top: 50px;">utility/arrays.h</h3>
    <p>[since release@2020.1]</p>
    <h1 style="border: 0.5px solid black;"></h1>
    <p>
        Implements searching, sorting, shuffling, etc, algorithms for arrays!<br>
        <a href="examples/arraysexample.html">Example</a>
    </p>
</div>

<div class="container">
    <h5 style="padding-top: 50px;">Typedefs</h5>
    <pre><code>
/*compares array1[i] with array2[j] and returns -1, 0 or 1 accordingly*/
/*since release@2020.1*/
typedef int(*ArrayIndicesComparator)(const void* array1, const void* array2, int i, int j);

/*compares key with array at index i i.e. array[i] & key*/
/*since release@2020.1*/
typedef int(*ArrayKeyComparator)(const void* array, const void* key, int i) ;

/*swaps the elements in array at index i and j*/
/*since release@2020.1*/
typedef void(*ArrayIndicesSwapper)(void* array, int i, int j);

/*copies the value at index i from source array to destination array*/
/*since release@2020.1*/
typedef void(*ArrayIndicesCopier)(const void* source, void* destination, int sourceIndex, int destinationIndex);
    </code></pre>
</div>

<div class="container">
    <h5 style="padding-top: 50px;">Functions summary</h5>
    <pre><code>

/*creates an integer array on heap of size N*/
/*do not populate array - returns a pointer to first element of array if succeeds otherwise returns a NULL pointer*/
/*asserts that input size is greater than zero*/
/*since release@2020.1*/
 int* new_int_array(int N);

/*creates an integer array on heap of size N and populates it with value*/
/*returns a pointer to first element of array if succeeds otherwise returns a NULL pointer*/
/*asserts that input size is greater than zero*/
/*since release@2020.1*/
 int* new_int_array_with(int N, int value);

/*creates a randomly populated integer array of size N in range [0...100]*/
/*and returns a pointer to it if succeeds otherwise returns a NULL pointer*/
/*asserts that input size is greater than zero*/
/*since release@2020.1*/
 int* new_random_int_array(int N);







/*creates a double array on heap of size N*/
/*do not populate array - returns a pointer to first element of array if succeeds otherwise returns a NULL pointer*/
/*asserts that input size is greater than zero*/
/*since release@2020.1*/
 double* new_double_array(int N);

/*creates a double array on heap of size N and populates with value*/
/*returns a pointer to first element of array if succeeds otherwise returns a NULL pointer*/
/*asserts that input size is greater than zero*/
/*since release@2020.1*/
 double* new_double_array_with(int N, double value);

/*creates a randomly populated double array of size N with values in range [0,1]*/
/*returns a pointer to 1st element of array if succeeds otherwise returns a NULL pointer*/
/*asserts that input size is greater than zero*/
/*since release@2020.1*/
 double* new_random_double_array(int N);







/*shuffles the content of array uniformly in given range*/
/*asserts that input array and callback not NULL and bounds are valid*/
/*since release@2020.1*/
 void shuffle_array(void* array, int low, int high, ArrayIndicesSwapper swap_callback);

/*reverses the content of array*/
/*asserts that array and callback aren't NULL and indices are in bound*/
/*since release@2020.1*/
 void reverse_array(void* array, int low,int high, ArrayIndicesSwapper indicesSwapper);




/*returns the index of first occurrence of key in array if exist otherwise returns -1*/
/*asserts that input array and callback aren't NULL and indices are in bound*/
/*since release@2020.1*/
 int linear_search(const void* array, int low, int high, const void* key, ArrayKeyComparator keyComparator);

/*returns the index of key which is closest to middle of array if exist otherwise returns -1*/
/*asserts that array, callback aren't NULL and indices are in bound*/
/*since release@2020.1*/
 int binary_search(const void* array, int low, int high, const void* key, ArrayKeyComparator keyComparator);







/*sorts the input array using insertion sort algorithm*/
/*asserts that array, auxiliary array and callbacks aren't NULL and indices are in bound*/
/*since release@2020.1*/
 void insertion_sort(void* array, int low, int high, ArrayIndicesComparator indicesComparator, ArrayIndicesSwapper indicesSwapper);

/*sorts the given input array using quick sort algorithm*/
/*asserts that array, auxiliary array and callbacks aren't NULL and indices are in bound*/
/*since release@2020.1*/
 void quick_sort(void* array, int low, int high, ArrayIndicesComparator indicesComparator, ArrayIndicesSwapper indicesSwapper);

/*sorts the given input array using merge sort algorithm*/
/*asserts that array, auxiliary array and callbacks aren't NULL and indices are in bound*/
/*since release@2020.1*/
 void merge_sort(void* array, void* auxiliary_array, int low, int high, ArrayIndicesComparator indicesComparator, ArrayIndicesCopier indicesCopier);



/*frees the memory allocated to array*/
/*asserts that input array is not NULL*/
/*since release@2020.1*/
 void free_array(void* array);
    </code></pre>
</div>
<div class="container">
    <h1 style="border: 0.5px solid black; margin-top: 50px;"></h1>
    <p style="text-align: center">
        Copyright (C) 2020 <a href="http://shubhampanchal.herokuapp.com">Shubham Panchal</a> - All rights reserved<br>
        <a href="../license.txt">GNU General Public License</a> <br>
    </p>
</div>
</body>
</html>